### Hook:
> React hooks were introduced in React version 16.8 as a way to easily add reusable, stateful logic to React function components.

#### useState:
>  useState is a React hook used in functional components to declare and manage state variables. It returns the current state value and a function to update it.
```
import React, { useState } from 'react';

function Counter() {
  // Declare a state variable 'count' with an initial value of 0
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
    </div>
  );
}

export default Counter;
```
----
#### useEffect
> useEffect is a hook in React that allows you to perform side effects in functional components.

> It is used for tasks like data fetching, DOM manipulation, and subscriptions.

> useEffect accepts two arguments: a function containing the side effect and an array of dependencies.

> **Dependencies**
```
  - An empty dependency array ([]) makes the effect run once right after the component first appears, like a setup.
  - When you specify dependencies, the effect runs whenever those things change, similar to reacting to specific changes.
  - Without specifying anything, the effect runs after every update, like a general-purpose watcher for updates.
```
```
import React, { useState, useEffect } from 'react';

function MyComponent() {
  // Step 1: Initialize state using the useState hook
  const [count, setCount] = useState(0);

  // Step 2: Create an effect for component mounting (componentDidMount equivalent)
  useEffect(() => {
    // This code runs when the component mounts
    console.log('Component mounted');
    
    // Step 4: Create a cleanup function for component unmounting (componentWillUnmount equivalent)
    return () => {
      // This code runs before the component unmounts
      console.log('Component will unmount');
    };
  }, []); // An empty dependency array means this effect runs once on mount

  // Step 3: Create an effect for component updating (componentDidUpdate equivalent)
  useEffect(() => {
    // This code runs after every render
    console.log('Component updated');
    
    // You can react to changes in state or props here
  });

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export default MyComponent;

```
----

